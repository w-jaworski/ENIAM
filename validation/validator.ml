(*
 *  ENIAMvalidator: tool for grammar validation based on parsed corpus
 *  Copyright (C) 2017-2021 Wojciech Jaworski <wjaworski atSPAMfree mimuw dot edu dot pl>
 *  Copyright (C) 2017-2018 Institute of Informatics, University of Warsaw
 *  Copyright (C) 2017-2018, 2022 SELIDOR - T. Puza, Ł. Wasilewski Sp.J.
 *
 *  This library is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *)

open SubsyntaxTypes
open Xstd
open Xjson

type sentence_split = Full | Partial (*| None*)

let eniam_built_in = ref true
let eniam_host = ref "localhost"
let eniam_port = ref 9760

let test_path = ref "."
let test_filename = ref ""
 
(* FIXME: dodać wypisywanie do pliku *)

let spec_list = [
  "-p", Arg.String (fun s -> test_path := Exec2.check_path s), "<path> test path"; 
  "-f", Arg.String (fun s -> test_filename := Exec2.check_filename s), "<filename> test filename";
  "--port2", Arg.Int (fun p -> eniam_built_in:=false; eniam_port:=p), "<port> Connect to ENIAM on a given port";
  "--host2", Arg.String (fun s -> eniam_built_in:=false; eniam_host:=s), "<hostname> Connect to ENIAM on a given host";
  ] @ Exec2.spec_list

let usage_msg =
  "Usage: validator <options>\nReparses a given JSON file with parsed texts and checks whether representations obtained via parsing are identical with original ones.\nOptions are:"

let message = "validator of meaning representation generated by ENIAM\n\
Copyright (C) 2021 Wojciech Jaworski <wjaworski atSPAMfree mimuw dot edu dot pl>"

let input_text channel =
  let s = ref (try input_line channel with End_of_file -> "") in
  let lines = ref [] in
  while !s <> "" do
    lines := !s :: !lines;
    s := try input_line channel with End_of_file -> ""
  done;
  String.concat "\n" (List.rev !lines)
  
let load_json_list filename =
  match json_of_string (File.load_file filename) with
    JArray l -> l
  | _ -> failwith "load_json_list"
  
let rec get_text_list = function
    ("text", JString s) :: _ -> s
  | _ :: l -> get_text_list l
  | [] -> raise Not_found
  
let rec get_text = function
    JObject["and",JArray l] -> 
      let s = Xlist.fold l "" (fun s t -> 
        try get_text t with Not_found -> s) in
      if s = "" then raise Not_found else s
  | JObject l -> get_text_list l
  | json -> print_endline ("get_text: " ^ json_to_string_fmt2 "" json); raise Not_found
  
let rec get_remove_alias_list rev = function
    ("alias", JString s) :: l -> s, List.rev rev @ l
  | t :: l -> get_remove_alias_list (t :: rev) l
  | [] -> raise Not_found
  
let rec get_remove_alias = function
    JObject["and",JArray l] -> 
      let s,l = Xlist.fold l ("",[]) (fun (s,l) t -> 
        let s,t = try get_remove_alias t with Not_found -> s, t in s, t :: l) in
      if s = "" then raise Not_found else s, JObject["and",JArray (List.rev l)]
  | JObject l -> let s,l = get_remove_alias_list [] l in s, JObject l
  | json -> print_endline ("get_remove_alias: " ^ json_to_string_fmt2 "" json); raise Not_found
  
let rec replace_text_list phrase rev = function
    ("text", _) :: l -> List.rev rev @ ["text",JString phrase] @ l
  | t :: l -> replace_text_list phrase (t :: rev) l
  | [] -> List.rev rev
  
let rec replace_text phrase = function
    JObject["and",JArray l] -> 
      let l = Xlist.fold l [] (fun l t -> 
        (replace_text phrase t) :: l) in
      JObject["and",JArray (List.rev l)]
  | JObject l -> let l = replace_text_list phrase [] l in JObject l
  | json -> print_endline ("replace_text: " ^ json_to_string_fmt2 "" json); raise Not_found
  
let validate sub_in sub_out eniam_in eniam_out t =
(*   print_endline ("validate 1: " ^ json_to_string_fmt2 "" t); *)
    let phrase = get_text t in
    let phrase,t = 
      try 
        let phrase,t = get_remove_alias t in
        phrase, replace_text phrase t
      with Not_found -> phrase,t in
(*   print_endline ("validate 2: " ^ phrase); *)
    if phrase = "" then print_endline ("Text not found in \n" ^ json_to_string_fmt2 "" t) else (
      try
        let t2 = 
          if !eniam_built_in then (
            let phrase2 = if !Exec2.correct_spelling_flag then FuzzyDetector.correct phrase else phrase in
(*   print_endline ("validate 3: " ^ phrase2); *)
            let text,tokens,lex_sems = Exec2.process sub_in sub_out phrase2 in
(*   print_endline ("validate 4: "); *)
            Json.normalize (Exec.Json2.convert false text))
          else (
            Printf.fprintf eniam_out "%s\n\n%!" phrase;
(*         print_endline ("A :" ^ phrase); *)
            let s = input_text eniam_in in
(*         print_endline ("Q :" ^ s); *)
            json_of_string s) in
(*   print_endline ("validate 5: "); *)
        if Json.simple_compare t t2 = 0 then () else (
        print_endline ("\n======================================\n\nOrig text: " ^ json_to_string_fmt2 "" t ^ ",");
        print_endline ("\nParsed text: " ^ json_to_string_fmt2 "" t2 ^ ","))
      with e -> print_endline phrase; print_endline (Printexc.to_string e))

  
(*let validate sub_in sub_out = function
    JObject(("text",JString raw_text) :: _) as json1 -> 
      let raw_text2 = if !correct_spelling_flag then FuzzyDetector.correct raw_text else raw_text in
      let text,tokens,lex_sems = process sub_in sub_out raw_text2 in
      (try
         let json2 = Json.normalize (Exec.Json2.convert false text) in
         if Json.simple_compare json1 json2 = 0 then () else
         Printf.printf "DIFFERENCE: %s\n%s\n%s\n%!" raw_text (json_to_string_fmt "" json1) (json_to_string_fmt "" json2)
      with e -> print_endline raw_text; print_endline (Printexc.to_string e))
  | _ -> failwith "validate"*)
  
(*let select_new raw_filename l =
  let known = Xlist.fold l StringSet.empty (fun known -> function 
      JObject(("text",JString raw_text) :: _) -> StringSet.add known raw_text
    | t -> failwith ("select_new 1: " ^ json_to_string_fmt "" t)) in
  let raw = File.load_tab raw_filename (function 
      [s] -> "",s
    | [i;s] -> i,s
    | _ -> failwith "select_new 2") in
  let raw = Xlist.fold raw [] (fun raw (i,s) -> if StringSet.mem known s then raw else (i,s) :: raw) in
  Xlist.iter (List.rev raw) (fun (i,s) ->
    print_endline (if !omit_labels_flag then s else i ^ "\t" ^ s))*)
    
 
let get_sock_addr host_name port =
  let he = Unix.gethostbyname host_name in
  let addr = he.Unix.h_addr_list in
  Unix.ADDR_INET(addr.(0),port)

let _ =
  prerr_endline message;
  Arg.parse spec_list Exec2.anon_fun usage_msg;
  if !test_filename = "" then (
    print_endline "Test filename not provided";
    exit 1);
  if !eniam_built_in then Exec2.initialize ();
  let sub_in,sub_out =
    if !Exec2.subsyntax_built_in then stdin,stdout
    else Unix.open_connection (get_sock_addr !Exec2.subsyntax_host !Exec2.subsyntax_port) in
  let eniam_in,eniam_out =
    if !eniam_built_in then stdin,stdout
    else Unix.open_connection (get_sock_addr !eniam_host !eniam_port) in
  prerr_endline "Ready!";
  let corpus = load_json_list (!test_path ^ !test_filename) in
  (*if !raw_filename = "" then*) Xlist.iter corpus (validate sub_in sub_out eniam_in eniam_out)
(*   else select_new !raw_filename l *)
