(*
 *  ENIAMschema: tool for verification of JSON structures generated by ENIAM
 *  Copyright (C) 2022 SELIDOR - T. Puza, Ł. Wasilewski Sp.J.
 *
 *  This library is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *)
 
open Xjson
open Xstd

  
(*let ex1 = json_of_string "{
\"patient\": {
  \"person\": \"się\"},
\"greetings\": \"dzień dobry\",
\"doer\": {
  \"person\": \"państwo\"},
\"client-data\": {
  \"gender\": \"f\"},
\"action\": {
  \"attitude\": \"chcieć\",
  \"name\": \"zapisać\"}}
"
let ex2 = json_of_string "{
  \"time\": {
    \"at\": {
      \"hour\": 20,
      \"minute\": 55}}}"
      
let ex3 = json_of_string "{
    \"at\": {
      \"hour\": 20,
      \"minute\": 55}}"
      
let ex4 = json_of_string "{
    \"hour\": {
      \"with\": [
        0,
        12]}}"*)
  
let schema_filename = ref ""
let test_path = ref "./"
let test_filename = ref ""
let print_flag = ref false
let result_type = ref ""
  
let check_filename s =
  if Xstring.check_sufix ".json" s then s else s ^ ".json"
  
let check_path s =
  if Xstring.check_sufix "/" s then s else s ^ "/"
        
let spec_list = [
  "-k", Arg.String (fun s -> schema_filename := check_filename s), "<filename> schema filename";
  "-p", Arg.String (fun s -> test_path := check_path s), "<path> test path";
  "-f", Arg.String (fun s -> test_filename := check_filename s), "<filename> test filename";
  "-r", Arg.String (fun s -> result_type := s), "<json type> result type";
  "--print-schema", Arg.Unit (fun () -> print_flag := true), "render schema to latex"; 
]

let usage_msg =
  "Usage: schema <options>\nOptions are:"
  
let anon_fun s = raise (Arg.Bad ("invalid argument: " ^ s))
 
let load_json_list filename =
  match json_of_string (File.load_file filename) with
    JArray l -> l
  | _ -> failwith "load_json_list"
  
let _ = 
  Arg.parse spec_list anon_fun usage_msg;
  if !schema_filename = "" then (
    print_endline "Schema filename not provided";
    exit 1);
  let l = 
     try XjsonSchema.load !schema_filename
     with Failure e -> print_endline e; exit 1 in
  if !print_flag then (
    Xlist.iter l (fun t -> print_endline (XjsonSchema.latex_of t)); 
    exit 0);
  if !test_filename = "" then (
    print_endline "Test filename not provided";
    exit 1);
  let schema = XjsonSchema.prepare_schema l in
(*   print_endline (XjsonSchema.string_of_type_expr (XjsonSchema.assign_type schema ex4)); *)
  let l = load_json_list (!test_path ^ !test_filename) in
  Xlist.iter l (fun t ->
    try
      let s = XjsonSchema.assign_type schema t in
      if !result_type = "" then () else
      if not (XjsonSchema.subsume_atom s !result_type) then 
        Printf.printf "Invalid result type '%s' in\n %s\n" 
          (XjsonSchema.string_of_type_expr s) (json_to_string_fmt2 "" t)
    with XjsonSchema.InvalidSchema(s,json) -> Printf.printf "\n%s in\n%s\n" s (json_to_string_fmt2 "" json));
  ()

(* ./schema | grep -e label | sort | uniq -c >eff2.txt *)
